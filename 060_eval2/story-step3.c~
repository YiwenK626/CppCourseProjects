#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "rand_story.h"

int main(int argc, char ** argv) {
  if (argc != 3) {
    fprintf(stderr, "invalid number of inputs for step3\n");
    exit(EXIT_FAILURE);
  }

  FILE * lib = fopen(argv[1], "r");
  FILE * template = fopen(argv[2], "r");
  if (lib == NULL || template == NULL) {
    perror("NULL input");
    exit(EXIT_FAILURE);
  }

  catarray_t * cats = malloc(sizeof(*cats));
  creatCats(lib, cats);
  parseTemp(template, cats);
  freeCatArr(cats, cats->n);
  return 0;
}

void creatCats(FILE * f, catarray_t * cats) {
  char * line = NULL;
  size_t size = 0;
  ssize_t len = 0;

  size_t n = 0;
  cats->n = n;
  cats->arr = malloc(n * sizeof(*cats->arr));
  char * temp = malloc(sizeof(*temp));

  while (len != EOF) {
    len = getline(&line, &size, f);
    if (strchr(line, ':') == NULL) {
      fprintf(stderr, "invalid input format for step2\n");
      exit(EXIT_FAILURE);
    }

    temp = realloc(temp, strlen(line) + 1);
    strcpy(temp, line);

    // get category & word
    char * cat = strtok(temp, ":");
    char * word = strtok(NULL, ":");
    word[strlen(word) - 1] = '\0';

    // store into catarray
    if (n == 0) {
      n = firstEntry(n, cats, cat, word);
    }
    else {
      int sign = 0;
      for (int i = 0; i < n; i++) {
        category_t * T = &cats->arr[i];
        if (strcmp(T->name, cat) == 0) {  // entry of exsting category
          sign = 1;                       // change sign if cat name exists
          for (int j = 0; j < T->n_words; j++) {
            if (strcmp(T->words[j], word) == 0) {
              sign = 2;  //change sign and exit loop if word exits
            }
          }
          if (sign == 1) {
            T->n_words++;  // add to words array if not exist
            T->words = realloc(T->words, T->n_words * sizeof(*T->words));
            T->words[T->n_words - 1] = malloc(strlen(word) + 1);
            strcpy(T->words[T->n_words - 1], word);
          }
        }
      }
      if (sign == 0) {  // first entry of the category
        n = firstEntry(n, cats, cat, word);
      }
    }
  }
  cats->n = n;
  //printWords(cats);
  free(temp);
  free(line);
  fclose(f);
}

void parseTemp(FILE * f, catarray_t * cats) {
  // parse template
  char * line = NULL;
  size_t size = 0;
  ssize_t len = 0;
  char * ptr;
  char * temp = malloc(sizeof(*temp));

  category_t * usedWords = malloc(sizeof(*usedWords));
  usedWords->name = malloc(strlen("usedWords") + 1);
  strcpy(usedWords->name, "usedWords");
  usedWords->n_words = 0;
  usedWords->words = malloc(sizeof(*usedWords->words));

  //char * target = malloc(sizeof(*target));

  while (len >= 0) {
    len = getline(&line, &size, f);

    if (len != EOF) {
      countDLT(line, '_', len);

      temp = realloc(temp, strlen(line) + 1);
      strcpy(temp, line);
      ptr = strtok(temp, "_");

      int i = 0;
      if (temp[0] == '_') {
        i++;
      }

      while (ptr != NULL) {
        // if text, print
        if (i % 2 == 0) {
          printf("%s", ptr);
          i++;
        }
        // if blanks, search
        else {
          // if cat, get word
          if (isdigit(*ptr) == 0) {
            char * target = printCat(ptr, cats);
            storeCat(target, usedWords);
            free(target);
          }
          // if numbers, get record
          else {
            //GET A PREVIOUSE ONE
            if (atoi(ptr) < 1) {
              fprintf(stderr, "fail to track back previous words with negative values\n");
              exit(EXIT_FAILURE);
            }
            else {
              int id = usedWords->n_words - atoi(ptr);
              if (id < 0) {
                fprintf(stderr, "integer blank index without previous words\n");
                exit(EXIT_FAILURE);
              }
              printf("%s", usedWords->words[id]);
              storeCat(usedWords->words[id], usedWords);
            }
          }
          i++;
        }
        ptr = strtok(NULL, "_");
      }
    }
  }
  free(temp);
  free(line);
  freeCat(*usedWords, usedWords->n_words);
  free(usedWords);
  fclose(f);
}
